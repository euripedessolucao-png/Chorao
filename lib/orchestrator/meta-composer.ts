import { countPoeticSyllables } from "@/lib/validation/syllable-counter"
import {
  type TerceiraViaAnalysis,
  analisarTerceiraVia,
  applyTerceiraViaToLine,
  ThirdWayEngine,
} from "@/lib/terceira-via"
import { getGenreConfig } from "@/lib/genre-config"
import { generateText } from "ai"
import {
  formatSertanejoPerformance,
  shouldUsePerformanceFormat,
} from "@/lib/formatters/sertanejo-performance-formatter"
import { AutoSyllableCorrector } from "@/lib/validation/auto-syllable-corrector"
import { PunctuationValidator } from "@/lib/validation/punctuation-validator"
import { LineStacker } from "@/lib/utils/line-stacker"
import { AbsoluteSyllableEnforcer } from "@/lib/validation/absolute-syllable-enforcer"
import { LyricsAuditor } from "@/lib/validation/lyrics-auditor"
import { MultiGenerationEngine } from "./multi-generation-engine"
import { WordIntegrityValidator } from "@/lib/validation/word-integrity-validator"
import { AggressiveAccentFixer } from "@/lib/validation/aggressive-accent-fixer"
import { RepetitionValidator } from "@/lib/validation/repetition-validator"
import { BrazilianGenrePredictor } from "@/lib/prediction/brazilian-genre-predictor"

export interface CompositionRequest {
  genre: string
  theme: string
  mood: string
  additionalRequirements?: string
  creativity?: "conservador" | "equilibrado" | "ousado"
  syllableTarget?: {
    min: number
    max: number
    ideal: number
  }
  applyFinalPolish?: boolean
  preservedChoruses?: string[]
  originalLyrics?: string
  rhythm?: string
  structureAnalysis?: any
  performanceMode?: "standard" | "performance"
  useTerceiraVia?: boolean
}

export interface CompositionResult {
  lyrics: string
  title: string
  metadata: {
    iterations: number
    finalScore: number
    polishingApplied?: boolean
    preservedChorusesUsed?: boolean
    rhymeScore?: number
    rhymeTarget?: number
    structureImproved?: boolean
    terceiraViaAnalysis?: TerceiraViaAnalysis
    melodicAnalysis?: any
    performanceMode?: string
    accentCorrections?: number
    syllableCorrections?: number
    predictedErrors?: string[]
    preventedErrors?: number
    strictSyllableEnforcement?: boolean
  }
}

export class MetaComposer {
  private static readonly MAX_ITERATIONS = 3
  private static readonly MAX_AUDIT_ATTEMPTS = 5
  private static readonly ABSOLUTE_MAX_SYLLABLES = 11 // REGRA ABSOLUTA - N√ÉO NEGOCI√ÅVEL
  private static readonly MIN_QUALITY_SCORE = 0.75

  /**
   * COMPOSI√á√ÉO COM REGRAS R√çGIDAS E TERCEIRA VIA AUTOM√ÅTICA
   */
  static async compose(request: CompositionRequest): Promise<CompositionResult> {
    console.log("[MetaComposer] üöÄ Iniciando composi√ß√£o com REGRAS R√çGIDAS...")
    console.log("[MetaComposer] üìè M√ÅXIMO 11 S√çLABAS - REGRA ABSOLUTA")
    console.log("[MetaComposer] üîÆ TERCEIRA VIA AUTOM√ÅTICA - SEMPRE ATIVA")

    // FOR√áA TERCEIRA VIA AUTOMATICAMENTE - SEM BOT√ÉO NECESS√ÅRIO
    const enhancedRequest = {
      ...request,
      useTerceiraVia: false // SEMPRE ATIVA - CORRE√á√ÉO SEM√ÇNTICA AUTOM√ÅTICA
    }

    // PREDI√á√ÉO DE ERROS COMUNS PARA O G√äNERO
    const predictedErrors = BrazilianGenrePredictor.predictCommonErrors(enhancedRequest.genre, enhancedRequest.theme)
    console.log(`[MetaComposer-PREDICTION] üîÆ Erros previstos:`, predictedErrors)

    const multiGenResult = await MultiGenerationEngine.generateMultipleVariations(
      async () => {
        return await this.generateSingleVersion(enhancedRequest, predictedErrors)
      },
      (lyrics) => {
        const auditResult = LyricsAuditor.audit(lyrics, enhancedRequest.genre, enhancedRequest.theme)
        return auditResult.score
      },
      3,
    )

    const bestVariation = multiGenResult.variations[multiGenResult.bestVariationIndex]
    const bestLyrics = bestVariation.lyrics
    const bestScore = multiGenResult.bestScore

    console.log(`[MetaComposer] üèÜ Melhor vers√£o escolhida! Score: ${bestScore}/100`)
    
    // APLICA CORRE√á√ÉO FINAL COM REGRAS R√çGIDAS
    console.log(`[MetaComposer] üîß Aplicando corre√ß√£o final com VALIDA√á√ÉO R√çGIDA...`)
    const finalLyrics = await this.applyStrictFinalCorrection(bestLyrics, enhancedRequest, predictedErrors)

    return {
      lyrics: finalLyrics,
      title: this.extractTitle(finalLyrics, enhancedRequest),
      metadata: {
        iterations: 3,
        finalScore: bestScore,
        polishingApplied: enhancedRequest.applyFinalPolish ?? true,
        preservedChorusesUsed: enhancedRequest.preservedChoruses ? enhancedRequest.preservedChoruses.length > 0 : false,
        performanceMode: enhancedRequest.performanceMode || "standard",
        accentCorrections: this.countAccentCorrections(bestLyrics, finalLyrics),
        syllableCorrections: this.countSyllableCorrections(bestLyrics, finalLyrics),
        predictedErrors: predictedErrors,
        preventedErrors: this.countPreventedErrors(predictedErrors, finalLyrics),
        strictSyllableEnforcement: true, // CONFIRMA REGRA R√çGIDA APLICADA
      },
    }
  }

  /**
   * CORRE√á√ÉO FINAL COM REGRAS R√çGIDAS - RESPEITA ABSOLUTAMENTE 11 S√çLABAS
   */
  private static async applyStrictFinalCorrection(
    lyrics: string, 
    request: CompositionRequest,
    predictedErrors: string[]
  ): Promise<string> {
    let correctedLyrics = lyrics
    
    console.log(`[MetaComposer-STRICT] üîß Aplicando valida√ß√£o r√≠gida de s√≠labas...`)
    
    // 1. VALIDA√á√ÉO R√çGIDA DE S√çLABAS - ABSOLUTA
    correctedLyrics = this.applyAbsoluteSyllableEnforcement(correctedLyrics)
    
    // 2. CORRE√á√ÉO PREDITIVA DE ACENTOS
    if (predictedErrors.some(error => error.includes('acento') || error.includes('palavra cortada'))) {
      console.log(`[MetaComposer-STRICT] üîß Aplicando corre√ß√£o preditiva de acentos...`)
      correctedLyrics = AggressiveAccentFixer.ultimateFix(correctedLyrics)
    }

    // 3. CORRE√á√ÉO PREDITIVA DE REPETI√á√ïES
    if (predictedErrors.some(error => error.includes('repeti√ß√£o') || error.includes('redundante'))) {
      console.log(`[MetaComposer-STRICT] üîß Aplicando corre√ß√£o preditiva de repeti√ß√µes...`)
      const repetitionResult = RepetitionValidator.fix(correctedLyrics)
      if (repetitionResult.corrections > 0) {
        correctedLyrics = repetitionResult.correctedLyrics
      }
    }

    // 4. CORRE√á√ÉO PREDITIVA DE INTEGRIDADE
    if (predictedErrors.some(error => error.includes('integridade') || error.includes('palavra incompleta'))) {
      console.log(`[MetaComposer-STRICT] üîß Aplicando corre√ß√£o preditiva de integridade...`)
      const integrityResult = WordIntegrityValidator.fix(correctedLyrics)
      if (integrityResult.corrections > 0) {
        correctedLyrics = integrityResult.correctedLyrics
      }
    }

    // 5. FORMATA√á√ÉO DE PERFORMANCE
    if (shouldUsePerformanceFormat(request.genre, request.performanceMode || "standard")) {
      console.log(`[MetaComposer-STRICT] üé≠ Aplicando formata√ß√£o de performance...`)
      correctedLyrics = formatSertanejoPerformance(correctedLyrics)
    }

    // VALIDA√á√ÉO FINAL ABSOLUTA
    const finalValidation = AbsoluteSyllableEnforcer.validate(correctedLyrics)
    if (!finalValidation.isValid) {
      console.warn(`[MetaComposer-STRICT] üö® VALIDA√á√ÉO FINAL FALHOU - APLICANDO CORRE√á√ÉO DE EMERG√äNCIA`)
      correctedLyrics = this.applyEmergencySyllableCorrection(correctedLyrics)
    }

    console.log(`[MetaComposer-STRICT] ‚úÖ Valida√ß√£o r√≠gida conclu√≠da - M√ÅXIMO 11 S√çLABAS GARANTIDO`)
    return correctedLyrics
  }

  /**
   * VALIDA√á√ÉO ABSOLUTA DE S√çLABAS - N√ÉO PERMITE EXCESSOS
   */
  private static applyAbsoluteSyllableEnforcement(lyrics: string): string {
    const lines = lyrics.split('\n')
    const correctedLines: string[] = []
    let violationsFixed = 0

    for (const line of lines) {
      if (!line.trim() || line.startsWith('[') || line.startsWith('(') || line.includes('Instruments:')) {
        correctedLines.push(line)
        continue
      }

      const syllables = countPoeticSyllables(line)
      
      if (syllables > this.ABSOLUTE_MAX_SYLLABLES) {
        console.warn(`[MetaComposer-STRICT] üö® VERSO COM ${syllables} S√çLABAS: "${line}"`)
        violationsFixed++
        
        // CORRE√á√ÉO AGRESSIVA - N√ÉO PERMITE EXCESSOS
        const correctedLine = this.aggressivelyFixLongVerse(line)
        correctedLines.push(correctedLine)
      } else {
        correctedLines.push(line)
      }
    }

    if (violationsFixed > 0) {
      console.log(`[MetaComposer-STRICT] üîß ${violationsFixed} viola√ß√µes de s√≠labas corrigidas`)
    }

    return correctedLines.join('\n')
  }

  /**
   * CORRE√á√ÉO AGRESSIVA PARA VERSOS LONGOS - RESPEITA LIMITE ABSOLUTO
   */
  private static aggressivelyFixLongVerse(line: string): string {
    const currentSyllables = countPoeticSyllables(line)
    
    // T√âCNICAS DE REDU√á√ÉO SEM CORTAR PALAVRAS
    let corrected = line
    
    // 1. Remove artigos desnecess√°rios
    corrected = corrected.replace(/\b(o|a|os|as|um|uma)\s+/gi, ' ')
    
    // 2. Aplica contra√ß√µes naturais
    corrected = corrected.replace(/\bpara\b/gi, 'pra')
    corrected = corrected.replace(/\best√°\b/gi, 't√°')
    corrected = corrected.replace(/\bestou\b/gi, 't√¥')
    corrected = corrected.replace(/\bvoc√™\b/gi, 'c√™')
    
    // 3. Remove preposi√ß√µes quando poss√≠vel
    corrected = corrected.replace(/\bde\s+/gi, ' ')
    corrected = corrected.replace(/\bem\s+/gi, ' ')
    corrected = corrected.replace(/\bpor\s+/gi, ' ')
    
    // 4. Simplifica express√µes
    corrected = corrected.replace(/\bque eu\b/gi, 'que')
    corrected = corrected.replace(/\bdo que\b/gi, 'que')
    corrected = corrected.replace(/\bmais do que\b/gi, 'mais que')
    
    const newSyllables = countPoeticSyllables(corrected)
    
    // Se ainda estiver longo ap√≥s corre√ß√µes, divide o verso
    if (newSyllables > this.ABSOLUTE_MAX_SYLLABLES) {
      const words = corrected.split(' ').filter(w => w.trim())
      if (words.length > 4) {
        const midPoint = Math.floor(words.length / 2)
        const firstHalf = words.slice(0, midPoint).join(' ')
        const secondHalf = words.slice(midPoint).join(' ')
        return `${firstHalf}\n${secondHalf}`
      }
    }
    
    return corrected
  }

  /**
   * CORRE√á√ÉO DE EMERG√äNCIA - GARANTE CUMPRIMENTO DA REGRA
   */
  private static applyEmergencySyllableCorrection(lyrics: string): string {
    console.log(`[MetaComposer-EMERGENCY] üö® APLICANDO CORRE√á√ÉO DE EMERG√äNCIA`)
    
    const lines = lyrics.split('\n')
    const emergencyLines: string[] = []
    
    for (const line of lines) {
      if (!line.trim() || line.startsWith('[') || line.startsWith('(')) {
        emergencyLines.push(line)
        continue
      }
      
      let currentLine = line
      let attempts = 0
      
      // Tenta reduzir at√© caber no limite
      while (countPoeticSyllables(currentLine) > this.ABSOLUTE_MAX_SYLLABLES && attempts < 5) {
        currentLine = this.aggressivelyFixLongVerse(currentLine)
        attempts++
      }
      
      // Se ainda n√£o couber, trunca (√∫ltimo recurso)
      if (countPoeticSyllables(currentLine) > this.ABSOLUTE_MAX_SYLLABLES) {
        const words = currentLine.split(' ').filter(w => w.trim())
        let truncated = ''
        let truncatedSyllables = 0
        
        for (const word of words) {
          const wordSyllables = countPoeticSyllables(word)
          if (truncatedSyllables + wordSyllables <= this.ABSOLUTE_MAX_SYLLABLES) {
            truncated += (truncated ? ' ' : '') + word
            truncatedSyllables += wordSyllables
          } else {
            break
          }
        }
        
        currentLine = truncated || words.slice(0, 3).join(' ')
        console.warn(`[MetaComposer-EMERGENCY] ‚ö†Ô∏è Verso truncado: "${line}" ‚Üí "${currentLine}"`)
      }
      
      emergencyLines.push(currentLine)
    }
    
    return emergencyLines.join('\n')
  }

  /**
   * GERA UMA VERS√ÉO COMPLETA DA LETRA COM REGRAS R√çGIDAS
   */
  private static async generateSingleVersion(
    request: CompositionRequest, 
    predictedErrors: string[] = []
  ): Promise<string> {
    console.log("[MetaComposer] üìù Gerando vers√£o √∫nica com REGRAS R√çGIDAS...")

    const syllableEnforcement = request.syllableTarget || this.getGenreSyllableConfig(request.genre)
    syllableEnforcement.max = Math.min(syllableEnforcement.max, this.ABSOLUTE_MAX_SYLLABLES)

    // GERA LETRA BASE COM REGRAS R√çGIDAS
    let rawLyrics: string

    if (request.originalLyrics) {
      rawLyrics = await this.generateRewrite(request, predictedErrors)
    } else if (request.preservedChoruses && request.preservedChoruses.length > 0) {
      rawLyrics = await this.generateWithPreservedChoruses(
        request.preservedChoruses, 
        request, 
        syllableEnforcement,
        predictedErrors
      )
    } else {
      rawLyrics = await this.generateDirectLyrics(request, syllableEnforcement, predictedErrors)
    }

    // APLICA CORRE√á√ÉO INSTANT√ÇNEA COM REGRAS R√çGIDAS
    console.log("[MetaComposer] üîß Aplicando corre√ß√£o instant√¢nea r√≠gida...")
    rawLyrics = this.applyInstantStrictCorrection(rawLyrics, request.genre, predictedErrors)

    // PIPELINE DE CORRE√á√ÉO EM TEMPO REAL
    console.log("[MetaComposer] üîß Executando pipeline de corre√ß√£o r√≠gida...")
    
    // 1. Corre√ß√£o agressiva de acentos
    const accentFixResult = AggressiveAccentFixer.fix(rawLyrics)
    if (accentFixResult.corrections.length > 0) {
      rawLyrics = accentFixResult.correctedText
      console.log(`[MetaComposer] ‚úÖ ${accentFixResult.corrections.length} corre√ß√µes de acento aplicadas`)
    }

    // 2. Corre√ß√£o de repeti√ß√µes
    const repetitionResult = RepetitionValidator.fix(rawLyrics)
    if (repetitionResult.corrections > 0) {
      rawLyrics = repetitionResult.correctedLyrics
      console.log(`[MetaComposer] ‚úÖ ${repetitionResult.corrections} repeti√ß√µes removidas`)
    }

    // 3. VALIDA√á√ÉO R√çGIDA DE S√çLABAS
    rawLyrics = this.applyAbsoluteSyllableEnforcement(rawLyrics)

    // 4. TERCEIRA VIA SEMPRE ATIVA - CORRE√á√ÉO SEM√ÇNTICA
    console.log("[MetaComposer] üîÆ Aplicando Terceira Via (autom√°tica)...")
    const terceiraViaAnalysis = analisarTerceiraVia(rawLyrics, request.genre, request.theme)
    if (terceiraViaAnalysis && terceiraViaAnalysis.score_geral < 85) {
      rawLyrics = await this.applyTerceiraViaCorrections(
        rawLyrics, 
        request, 
        terceiraViaAnalysis, 
        getGenreConfig(request.genre)
      )
      
      // RE-VALIDA S√çLABAS AP√ìS TERCEIRA VIA
      rawLyrics = this.applyAbsoluteSyllableEnforcement(rawLyrics)
    }

    // 5. Valida√ß√£o de integridade final
    const integrityCheck = WordIntegrityValidator.validate(rawLyrics)
    if (!integrityCheck.isValid) {
      console.log("[MetaComposer] üîß Aplicando corre√ß√£o final de integridade...")
      const fixResult = WordIntegrityValidator.fix(rawLyrics)
      rawLyrics = fixResult.correctedLyrics
      
      // RE-VALIDA S√çLABAS AP√ìS CORRE√á√ÉO DE INTEGRIDADE
      rawLyrics = this.applyAbsoluteSyllableEnforcement(rawLyrics)
    }

    return rawLyrics
  }

  /**
   * CORRE√á√ÉO INSTANT√ÇNEA COM REGRAS R√çGIDAS
   */
  private static applyInstantStrictCorrection(
    lyrics: string, 
    genre: string,
    predictedErrors: string[]
  ): string {
    console.log("[MetaComposer] üîß Aplicando corre√ß√£o instant√¢nea r√≠gida...")
    
    let corrected = lyrics
    
    // CORRE√á√ïES CR√çTICAS - ERROS ABSOLUTOS
    const strictFixes = [
      // ERROS CR√çTICOS - PALAVRAS COLAVAS
      { regex: /N√£tinha/gi, correction: 'N√£o tinha', description: 'Palavras coladas com n√£' },
      { regex: /n√£posso/gi, correction: 'n√£o posso', description: 'Palavras coladas com n√£' },
      { regex: /n√£mora/gi, correction: 'n√£o mora', description: 'Palavras coladas com n√£' },
      { regex: /n√£ganhava/gi, correction: 'n√£o ganhava', description: 'Palavras coladas com n√£' },
      
      // ERROS DE ACENTUA√á√ÉO CR√çTICOS
      { regex: /l√°√ßo/gi, correction: 'la√ßo', description: 'Acento incorreto' },
      { regex: /n√£oo/gi, correction: 'n√£o', description: 'Acento duplicado' },
      
      // ERROS DE PREPOSI√á√ÉO CR√çTICOS
      { regex: /cavalo ra√ßa/gi, correction: 'cavalo de ra√ßa', description: 'Preposi√ß√£o faltando' },
      { regex: /perdi f√©/gi, correction: 'perdi a f√©', description: 'Artigo faltando' },
      { regex: /firmeestrada/gi, correction: 'firme na estrada', description: 'Preposi√ß√£o faltando' },
      { regex: /n'areia/gi, correction: 'na areia', description: 'Contra√ß√£o incorreta' },
    ]

    strictFixes.forEach(({ regex, correction, description }) => {
      const matches = corrected.match(regex)
      if (matches) {
        corrected = corrected.replace(regex, correction)
        console.log(`[MetaComposer-STRICT] üîß ${description}: "${matches[0]}" ‚Üí "${correction}"`)
      }
    })
    
    return corrected
  }

  /**
   * GERA LETRA DIRETA COM REGRAS R√çGIDAS EXPL√çCITAS
   */
  private static async generateDirectLyrics(
    request: CompositionRequest,
    syllableEnforcement: { min: number; max: number; ideal: number },
    predictedErrors: string[] = []
  ): Promise<string> {
    console.log("[MetaComposer] Gerando letra com REGRAS R√çGIDAS...")

    const directPrompt = `Voc√™ √© um compositor profissional de ${request.genre}. 
Crie uma letra AUT√äNTICA seguindo estas REGRAS ABSOLUTAS:

TEMA: ${request.theme}
MOOD: ${request.mood}
${request.rhythm ? `RITMO: ${request.rhythm}` : ""}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üö® REGRAS ABSOLUTAS - N√ÉO NEGOCI√ÅVEIS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**1. LIMITE DE S√çLABAS - M√ÅXIMO 11 POR VERSO:**
‚ùå NUNCA escreva versos com 12 ou mais s√≠labas
‚úÖ SEMPRE verifique: cada verso deve ter M√ÅXIMO 11 s√≠labas po√©ticas

**2. PALAVRAS COMPLETAS E ACENTUADAS:**
‚ùå NUNCA: "n√£", "seguran√ß", "heran√ß", "ra√ß", "la√ß", "n√£oo"
‚úÖ SEMPRE: "n√£o", "seguran√ßa", "heran√ßa", "ra√ßa", "la√ßo"

**3. EXPRESS√ïES COMPLETAS:**
‚ùå NUNCA: "cavalo ra√ßa", "perdi f√©", "firmeestrada"
‚úÖ SEMPRE: "cavalo de ra√ßa", "perdi a f√©", "firme na estrada"

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üéØ T√âCNICAS PARA RESPEITAR 11 S√çLABAS (SEM CORTAR PALAVRAS)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**QUANDO PRECISAR REDUZIR:**
‚úÖ Remova artigos: "o", "a", "um", "uma" (quando poss√≠vel)
‚úÖ Use contra√ß√µes: "pra", "t√°", "t√¥", "c√™"
‚úÖ Simplifique: "que eu tenho" ‚Üí "que tenho"
‚úÖ Remova preposi√ß√µes: "de", "em", "por" (quando poss√≠vel)

**EXEMPLOS DE CORRE√á√ÉO:**
‚úÖ "por entre os dedos" (6 s√≠labas) ‚Üí "entre os dedos" (4 s√≠labas)
‚úÖ "Comprando rem√©dios" (6 s√≠labas) ‚Üí "Compro rem√©dio" (5 s√≠labas)  
‚úÖ "o meu cora√ß√£o" (5 s√≠labas) ‚Üí "meu cora√ß√£o" (4 s√≠labas)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üéµ ESTRUTURA SUGERIDA - ${request.genre.toUpperCase()}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

${this.getGenreStructureGuide(request.genre)}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ö†Ô∏è VALIDA√á√ÉO OBRIGAT√ìRIA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

ANTES DE FINALIZAR, VERIFIQUE:
‚úì Cada verso tem M√ÅXIMO 11 s√≠labas
‚úì Nenhuma palavra est√° cortada ou sem acento  
‚úì Todas as express√µes est√£o completas
‚úì A emo√ß√£o e coer√™ncia est√£o preservadas

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Retorne APENAS a letra (sem explica√ß√µes):`

    try {
      const response = await generateText({
        model: "openai/gpt-4o",
        prompt: directPrompt,
        temperature: 0.5,
      })

      return response.text || ""
    } catch (error) {
      console.error("[MetaComposer] Erro ao gerar letra direta:", error)
      throw error
    }
  }

  /**
   * GERA REESCRITA COM REGRAS R√çGIDAS
   */
  private static async generateRewrite(
    request: CompositionRequest, 
    predictedErrors: string[] = []
  ): Promise<string> {
    console.log("[MetaComposer] Gerando reescrita com REGRAS R√çGIDAS...")

    if (!request.originalLyrics) {
      throw new Error("Original lyrics required for rewrite")
    }

    const rewritePrompt = `Voc√™ √© um compositor profissional de ${request.genre}. 
Reescreva esta letra aplicando REGRAS R√çGIDAS:

LETRA ORIGINAL:
${request.originalLyrics}

TEMA: ${request.theme}
MOOD: ${request.mood}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üö® CORRE√á√ïES OBRIGAT√ìRIAS - REGRAS ABSOLUTAS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**1. LIMITE DE S√çLABAS:**
‚úÖ GARANTIR que CADA verso tenha M√ÅXIMO 11 s√≠labas
‚ùå NUNCA permitir versos com 12+ s√≠labas

**2. CORRIGIR ERROS CR√çTICOS:**
‚ùå "n√£", "n√£oo", "n√£ganhava" ‚Üí ‚úÖ "n√£o", "n√£o ganhava"
‚ùå "seguran√ß", "heran√ß" ‚Üí ‚úÖ "seguran√ßa", "heran√ßa"  
‚ùå "ra√ß", "la√ß" ‚Üí ‚úÖ "ra√ßa", "la√ßo"
‚ùå "cavalo ra√ßa" ‚Üí ‚úÖ "cavalo de ra√ßa"
‚ùå "perdi f√©" ‚Üí ‚úÖ "perdi a f√©"
‚ùå "firmeestrada" ‚Üí ‚úÖ "firme na estrada"

**3. T√âCNICAS DE REDU√á√ÉO (SEM CORTAR PALAVRAS):**
‚úÖ Remover artigos desnecess√°rios
‚úÖ Usar contra√ß√µes naturais ("pra", "t√°", "c√™")
‚úÖ Simplificar estruturas frasais
‚úÖ Manover integridade das palavras

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Retorne APENAS a letra reescrita (sem explica√ß√µes):`

    try {
      const response = await generateText({
        model: "openai/gpt-4o",
        prompt: rewritePrompt,
        temperature: 0.5,
      })

      return response.text || request.originalLyrics
    } catch (error) {
      console.error("[MetaComposer] Erro ao gerar reescrita:", error)
      return request.originalLyrics
    }
  }

  /**
   * GERA LETRA COM REFR√ïES PRESERVADOS E REGRAS R√çGIDAS
   */
  private static async generateWithPreservedChoruses(
    preservedChoruses: string[],
    request: CompositionRequest,
    syllableEnforcement: { min: number; max: number; ideal: number },
    predictedErrors: string[] = []
  ): Promise<string> {
    console.log("[MetaComposer] Gerando letra com refr√µes preservados e REGRAS R√çGIDAS...")

    const chorusPrompt = `Voc√™ √© um compositor profissional de ${request.genre}. 
Crie uma letra usando EXATAMENTE estes refr√µes e seguindo REGRAS R√çGIDAS:

REFRAÃÉOS PRESERVADOS:
${preservedChoruses.join("\n\n")}

TEMA: ${request.theme}
MOOD: ${request.mood}

üö® REGRAS ABSOLUTAS:

1. S√çLABAS: M√ÅXIMO 11 por verso (VERIFIQUE CADA VERSO)
2. ACENTUA√á√ÉO: Palavras COMPLETAS com acentos corretos
3. INTEGRIDADE: NUNCA corte palavras ou remova acentos
4. EXPRESS√ïES: Todas as frases devem estar completas

ERROS CR√çTICOS PROIBIDOS:
- "n√£", "n√£oo", "seguran√ß", "heran√ß", "ra√ß", "la√ß"
- "cavalo ra√ßa" (use "cavalo de ra√ßa")
- "perdi f√©" (use "perdi a f√©")
- Qualquer verso com 12+ s√≠labas

T√âCNICAS PERMITIDAS PARA REDUZIR S√çLABAS:
- Remover artigos: "o", "a", "um", "uma"
- Usar contra√ß√µes: "pra", "t√°", "t√¥", "c√™" 
- Simplificar frases sem perder significado

Retorne a letra completa com os refr√µes preservados:`

    try {
      const response = await generateText({
        model: "openai/gpt-4o",
        prompt: chorusPrompt,
        temperature: 0.7,
      })

      return response.text || ""
    } catch (error) {
      console.error("[MetaComposer] Erro ao gerar letra com refr√µes preservados:", error)
      return ""
    }
  }

  // ... (m√©todos auxiliares mantidos do c√≥digo anterior - getGenreStructureGuide, countAccentCorrections, countSyllableCorrections, etc.)

  private static getGenreStructureGuide(genre: string): string {
    const structureGuides: Record<string, string> = {
      "sertanejo-moderno": `**VERSOS (8-11 s√≠labas - M√ÅXIMO 11):**
- Hist√≥ria de amor/cotidiano sertanejo
- Linguagem coloquial: "c√™", "t√¥", "pra", "t√°"
- Refer√™ncias: estrada, paix√£o, saudade, boteco

**CHORUS (8-9 s√≠labas):**
- Repetitivo e grudento
- F√°cil memoriza√ß√£o
- Emo√ß√£o intensa DENTRO do limite de s√≠labas`,

      "sertanejo-universitario": `**VERSOS (7-10 s√≠labas - M√ÅXIMO 11):**
- Festa, amor universit√°rio, amizade
- G√≠rias: "fest√£o", "zoeira", "rol√™"
- Sempre respeitando M√ÅXIMO 11 s√≠labas`,

      "piseiro": `**VERSOS (6-9 s√≠labas - M√ÅXIMO 11):**
- Ritmo acelerado e dan√ßante
- Letras simples e diretas
- F√°cil de cantar DENTRO dos limites`,

      "forro": `**VERSOS (8-11 s√≠labas - M√ÅXIMO 11):**
- Amor, nordeste, saudade
- Linguagem regional natural
- Respeitando estrutura tradicional`,

      "funk": `**VERSOS (6-9 s√≠labas - M√ÅXIMO 11):**
- Batida forte e letras diretas
- G√≠rias cariocas aut√™nticas
- Dentro do limite t√©cnico`,

      "trap": `**VERSOS (7-10 s√≠labas - M√ÅXIMO 11):**
- Flow quebrado e rimas complexas
- Tem√°ticas realistas
- Respeitando m√©trica brasileira`
    }

    return structureGuides[genre] || structureGuides["sertanejo-moderno"]
  }

  private static countAccentCorrections(original: string, corrected: string): number {
    if (original === corrected) return 0
    
    const originalWords = original.split(/\s+/).filter(word => word.length > 2)
    const correctedWords = corrected.split(/\s+/).filter(word => word.length > 2)
    
    let corrections = 0
    for (let i = 0; i < Math.min(originalWords.length, correctedWords.length); i++) {
      if (originalWords[i] !== correctedWords[i]) {
        corrections++
      }
    }
    
    return corrections
  }

  private static countSyllableCorrections(original: string, corrected: string): number {
    const originalLines = original.split('\n').filter(line => 
      line.trim() && !line.startsWith('[') && !line.startsWith('(')
    )
    const correctedLines = corrected.split('\n').filter(line => 
      line.trim() && !line.startsWith('[') && !line.startsWith('(')
    )
    
    let corrections = 0
    for (let i = 0; i < Math.min(originalLines.length, correctedLines.length); i++) {
      const originalSyllables = countPoeticSyllables(originalLines[i])
      const correctedSyllables = countPoeticSyllables(correctedLines[i])
      
      if (originalSyllables !== correctedSyllables) {
        corrections++
      }
    }
    
    return corrections
  }

  private static countPreventedErrors(predictedErrors: string[], finalLyrics: string): number {
    let prevented = 0
    
    predictedErrors.forEach(error => {
      if (error.includes('n√£') && !finalLyrics.toLowerCase().includes('n√£')) {
        prevented++
      }
      if (error.includes('acento') && !this.hasAccentErrors(finalLyrics)) {
        prevented++
      }
      if (error.includes('s√≠laba') && this.hasPerfectSyllableDistribution(finalLyrics)) {
        prevented++
      }
    })
    
    return prevented
  }

  private static hasAccentErrors(lyrics: string): boolean {
    const commonErrors = [/n√£[^o]/gi, /seguran√ß/gi, /heran√ß/gi, /ra√ß[^a]/gi, /la√ß[^o]/gi]
    return commonErrors.some(regex => regex.test(lyrics))
  }

  private static hasPerfectSyllableDistribution(lyrics: string): boolean {
    const lines = lyrics.split('\n').filter(line => 
      line.trim() && !line.startsWith('[') && !line.startsWith('(')
    )
    
    const validLines = lines.filter(line => {
      const syllables = countPoeticSyllables(line)
      return syllables <= this.ABSOLUTE_MAX_SYLLABLES // M√ÅXIMO 11
    })
    
    return validLines.length === lines.length // TODOS os versos devem estar dentro do limite
  }

  private static getGenreSyllableConfig(genre: string): { min: number; max: number; ideal: number } {
    const genreConfig = getGenreConfig(genre)
    const syllableRules = genreConfig.prosody_rules?.syllable_count

    if (syllableRules && "absolute_max" in syllableRules) {
      return {
        min: 7,
        max: Math.min(syllableRules.absolute_max, this.ABSOLUTE_MAX_SYLLABLES), // FOR√áA M√ÅXIMO 11
        ideal: 10,
      }
    } else if (syllableRules && "without_comma" in syllableRules) {
      return {
        min: syllableRules.without_comma.min,
        max: Math.min(syllableRules.without_comma.acceptable_up_to, this.ABSOLUTE_MAX_SYLLABLES), // FOR√áA M√ÅXIMO 11
        ideal: Math.floor((syllableRules.without_comma.min + syllableRules.without_comma.max) / 2),
      }
    }

    return {
      min: 7,
      max: this.ABSOLUTE_MAX_SYLABLES, // SEMPRE 11
      ideal: 10,
    }
  }

  private static extractTitle(lyrics: string, request: CompositionRequest): string {
    const lines = lyrics.split('\n')

    for (const line of lines) {
      if (line.toLowerCase().includes('t√≠tulo:') || line.toLowerCase().includes('title:')) {
        return line.split(':')[1]?.trim() || 'Sem T√≠tulo'
      }
    }

    for (const line of lines) {
      const cleaned = line.trim()
      if (cleaned && !cleaned.startsWith('[') && !cleaned.startsWith('(') && cleaned.length > 3) {
        return cleaned.substring(0, 50)
      }
    }

    return `${request.theme} - ${request.genre}`
  }

  private static async applyTerceiraViaCorrections(
    lyrics: string,
    request: CompositionRequest,
    analysis: TerceiraViaAnalysis,
    genreConfig: any,
  ): Promise<string> {
    const lines = lyrics.split('\n')
    const correctedLines: string[] = []
    let correctionsApplied = 0

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i]

      if (this.needsTerceiraViaCorrection(line, analysis)) {
        try {
          const context = this.buildLineContext(lines, i, '')
          const correctedLine = await applyTerceiraViaToLine(line, i, context, false, '', request.genre)

          if (correctedLine !== line) {
            correctionsApplied++
            console.log(`[TerceiraVia] üîÑ Linha ${i} corrigida: "${line}" ‚Üí "${correctedLine}"`)
          }

          correctedLines.push(correctedLine)
        } catch (error) {
          console.warn(`[TerceiraVia] ‚ùå Erro na linha ${i}, mantendo original`)
          correctedLines.push(line)
        }
      } else {
        correctedLines.push(line)
      }
    }

    console.log(`[MetaComposer] ‚úÖ ${correctionsApplied} corre√ß√µes Terceira Via aplicadas`)
    return correctedLines.join('\n')
  }

  private static needsTerceiraViaCorrection(line: string, analysis: TerceiraViaAnalysis): boolean {
    if (!line.trim() || line.startsWith('[') || line.startsWith('(') || line.includes('Instruments:')) {
      return false
    }

    if (analysis.score_geral < 85) { // LIMITE MAIS R√çGIDO
      return true
    }

    if (analysis.pontos_fracos && analysis.pontos_fracos.length > 0) {
      return true
    }

    return false
  }

  private static buildLineContext(lines: string[], lineIndex: number, theme: string): string {
    const contextLines: string[] = []

    if (lineIndex > 0) {
      contextLines.push(`Linha anterior: ${lines[lineIndex - 1]}`)
    }

    contextLines.push(`Linha atual: ${lines[lineIndex]}`)

    if (lineIndex < lines.length - 1) {
      contextLines.push(`Pr√≥xima linha: ${lines[lineIndex + 1]}`)
    }

    contextLines.push(`Tema: ${theme}`)

    return contextLines.join('\n')
  }
}
