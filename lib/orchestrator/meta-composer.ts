import { countPoeticSyllables } from "@/lib/validation/syllable-counter"
import {
  type TerceiraViaAnalysis,
  analisarTerceiraVia,
  applyTerceiraViaToLine,
  analisarMelodiaRitmo,
  ThirdWayEngine,
} from "@/lib/terceira-via"
import { getGenreConfig } from "@/lib/genre-config"
import { generateText } from "ai"
import { validateRhymesForGenre } from "@/lib/validation/rhyme-validator"
import { validateVerseIntegrity } from "@/lib/validation/verse-integrity-validator"
import {
  formatSertanejoPerformance,
  shouldUsePerformanceFormat,
} from "@/lib/formatters/sertanejo-performance-formatter"
import { validateNarrativeFlow } from "@/lib/validation/narrative-validator"
import { SyllableEnforcer } from "@/lib/validation/syllableEnforcer"

export interface CompositionRequest {
  genre: string
  theme: string
  mood: string
  additionalRequirements?: string
  creativity?: "conservador" | "equilibrado" | "ousado"
  syllableTarget?: {
    min: number
    max: number
    ideal: number
  }
  applyFinalPolish?: boolean
  preservedChoruses?: string[]
  originalLyrics?: string
  rhythm?: string
  structureAnalysis?: any
  performanceMode?: "standard" | "performance"
}

export interface CompositionResult {
  lyrics: string
  title: string
  metadata: {
    iterations: number
    finalScore: number
    polishingApplied?: boolean
    preservedChorusesUsed?: boolean
    rhymeScore?: number
    rhymeTarget?: number
    structureImproved?: boolean
    terceiraViaAnalysis?: TerceiraViaAnalysis
    melodicAnalysis?: any
    performanceMode?: string
  }
}

export class MetaComposer {
  private static readonly MAX_ITERATIONS = 3
  private static readonly ABSOLUTE_MAX_SYLLABLES = 11
  private static readonly MIN_QUALITY_SCORE = 0.75 // Score m√≠nimo para aprovar letra

  /**
   * Obt√©m a configura√ß√£o de s√≠labas para um g√™nero espec√≠fico
   */
  private static getGenreSyllableConfig(genre: string): { min: number; max: number; ideal: number } {
    const genreConfig = getGenreConfig(genre)
    const syllableRules = genreConfig.prosody_rules?.syllable_count

    // Handle different syllable count structures across genres
    if (syllableRules && "absolute_max" in syllableRules) {
      // Sertanejo Moderno structure
      return {
        min: 7,
        max: syllableRules.absolute_max,
        ideal: 10,
      }
    } else if (syllableRules && "without_comma" in syllableRules) {
      // Other genres structure
      return {
        min: syllableRules.without_comma.min,
        max: syllableRules.without_comma.acceptable_up_to,
        ideal: Math.floor((syllableRules.without_comma.min + syllableRules.without_comma.max) / 2),
      }
    }

    // Default fallback
    return {
      min: 7,
      max: 11,
      ideal: 10,
    }
  }

  /**
   * COMPOSI√á√ÉO TURBO COM SISTEMA TERCEIRA VIA INTEGRADO
   */
  static async compose(request: CompositionRequest): Promise<CompositionResult> {
    console.log("[MetaComposer-TURBO] Iniciando composi√ß√£o com Terceira Via...")
    console.log("[MetaComposer-TURBO] üß™ MODO EXPERIMENTAL: SyllableEnforcer DESABILITADO")

    let iterations = 0
    let bestResult: CompositionResult | null = null
    let bestScore = 0
    let terceiraViaAnalysis: TerceiraViaAnalysis | null = null
    let melodicAnalysis: any = null

    const syllableEnforcement = request.syllableTarget || this.getGenreSyllableConfig(request.genre)
    syllableEnforcement.max = Math.min(syllableEnforcement.max, this.ABSOLUTE_MAX_SYLLABLES)

    const applyFinalPolish = request.applyFinalPolish ?? true
    const preservedChoruses = request.preservedChoruses || []
    const hasPreservedChoruses = preservedChoruses.length > 0
    const isRewrite = !!request.originalLyrics
    const performanceMode = request.performanceMode || "standard"

    const genreConfig = getGenreConfig(request.genre)

    while (iterations < this.MAX_ITERATIONS) {
      iterations++
      console.log(`[MetaComposer-TURBO] Itera√ß√£o ${iterations}/${this.MAX_ITERATIONS}`)

      let rawLyrics: string

      if (isRewrite) {
        rawLyrics = await this.generateRewrite(request)
      } else if (hasPreservedChoruses && iterations === 1) {
        rawLyrics = await this.generateWithPreservedChoruses(preservedChoruses, request, syllableEnforcement)
      } else {
        rawLyrics = await this.generateDirectLyrics(request, syllableEnforcement)
      }

      const criticalViolations = this.detectCriticalViolations(rawLyrics)
      if (criticalViolations.length > 0) {
        console.error(`[MetaComposer-TURBO] ‚ùå VIOLA√á√ÉO CR√çTICA: ${criticalViolations.length} versos com >11 s√≠labas`)
        criticalViolations.forEach((v) => {
          console.error(`  Linha ${v.lineNumber}: "${v.line}" (${v.syllables} s√≠labas)`)
        })

        // Se n√£o √© a √∫ltima itera√ß√£o, tenta novamente
        if (iterations < this.MAX_ITERATIONS) {
          console.log("[MetaComposer-TURBO] üîÑ Regenerando devido a viola√ß√µes cr√≠ticas...")
          continue
        }
      }

      // ‚úÖ ETAPA 1: AN√ÅLISE TERCEIRA VIA COM CONFIGURA√á√ÉO DO G√äNERO
      console.log("[MetaComposer-TURBO] üîç Aplicando an√°lise Terceira Via...")
      terceiraViaAnalysis = analisarTerceiraVia(rawLyrics, request.genre, request.theme)
      melodicAnalysis = analisarMelodiaRitmo(rawLyrics, request.genre)

      console.log(`[MetaComposer-TURBO] üìä Score Terceira Via: ${terceiraViaAnalysis.score_geral}/100`)
      console.log(`[MetaComposer-TURBO] üéµ Score Mel√≥dico: ${melodicAnalysis.flow_score}/100`)

      // ‚úÖ ETAPA 2: CORRE√á√ïES INTELIGENTES COM THIRD WAY ENGINE
      if (terceiraViaAnalysis.score_geral < 75 && iterations < this.MAX_ITERATIONS - 1) {
        console.log("[MetaComposer-TURBO] üéØ Aplicando corre√ß√µes Terceira Via...")
        rawLyrics = await this.applyTerceiraViaCorrections(rawLyrics, request, terceiraViaAnalysis, genreConfig)

        // ‚úÖ RE-ANALISA AP√ìS CORRE√á√ïES
        terceiraViaAnalysis = analisarTerceiraVia(rawLyrics, request.genre, request.theme)
        console.log(`[MetaComposer-TURBO] üìä Score ap√≥s corre√ß√µes: ${terceiraViaAnalysis.score_geral}/100`)
      }

      // ‚úÖ ETAPA 3: CORRE√á√ÉO DE S√çLABAS COM LIMITE ABSOLUTO
      console.log("[MetaComposer-TURBO] üìè Aplicando corre√ß√£o de s√≠labas...")
      const enforcedResult = await SyllableEnforcer.enforceSyllableLimits(rawLyrics, syllableEnforcement, request.genre)
      console.log(`[MetaComposer-TURBO] ‚úÖ Corre√ß√µes de s√≠labas: ${enforcedResult.corrections} linhas`)

      const postCorrectionViolations = this.detectCriticalViolations(enforcedResult.correctedLyrics)
      if (postCorrectionViolations.length > 0) {
        console.error(`[MetaComposer-TURBO] ‚ùå AINDA H√Å VIOLA√á√ïES ap√≥s corre√ß√£o: ${postCorrectionViolations.length}`)

        // Aplica corre√ß√£o emergencial linha por linha
        enforcedResult.correctedLyrics = this.applyEmergencyCorrection(
          enforcedResult.correctedLyrics,
          syllableEnforcement.max,
        )
      }

      let finalLyrics = enforcedResult.correctedLyrics
      let polishingApplied = false

      // ‚úÖ ETAPA 4: POLIMENTO FINAL COM TERCEIRA VIA
      if (applyFinalPolish && iterations === this.MAX_ITERATIONS) {
        console.log("[MetaComposer-TURBO] ‚ú® Aplicando polimento universal com Terceira Via...")
        finalLyrics = await this.applyUniversalPolish(
          finalLyrics,
          request.genre,
          request.theme,
          syllableEnforcement,
          performanceMode,
          genreConfig,
        )
        polishingApplied = true
      }

      const finalViolations = this.detectCriticalViolations(finalLyrics)
      if (finalViolations.length > 0) {
        console.error(`[MetaComposer-TURBO] ‚ùå VIOLA√á√ïES FINAIS DETECTADAS: ${finalViolations.length}`)
        finalLyrics = this.applyEmergencyCorrection(finalLyrics, syllableEnforcement.max)
        console.log("[MetaComposer-TURBO] ‚úÖ Corre√ß√£o emergencial aplicada")
      }

      const finalValidation = this.validateFinalLyrics(finalLyrics, request.genre, syllableEnforcement)

      if (!finalValidation.isValid) {
        console.error(`[MetaComposer-TURBO] ‚ùå VALIDA√á√ÉO FINAL FALHOU:`)
        finalValidation.criticalErrors.forEach((error) => console.error(`  - ${error}`))

        // Se n√£o √© a √∫ltima itera√ß√£o, REGENERA
        if (iterations < this.MAX_ITERATIONS) {
          console.log("[MetaComposer-TURBO] üîÑ REGENERANDO devido a falhas cr√≠ticas...")
          continue
        } else {
          // √öltima itera√ß√£o: aplica corre√ß√µes emergenciais
          console.log("[MetaComposer-TURBO] ‚ö†Ô∏è √öltima itera√ß√£o - aplicando corre√ß√µes emergenciais...")
          finalLyrics = this.applyFinalEmergencyFixes(finalLyrics, syllableEnforcement, request.genre)
        }
      } else {
        console.log("[MetaComposer-TURBO] ‚úÖ VALIDA√á√ÉO FINAL APROVADA!")
        console.log(`  - S√≠labas: ${finalValidation.syllableCompliance}% dentro do limite`)
        console.log(`  - Rimas: ${finalValidation.rhymeQuality}% de qualidade`)
        console.log(`  - Integridade: ${finalValidation.verseIntegrity}% versos completos`)
        console.log(`  - Narrativa: ${finalValidation.hasNarrative ? "‚úì" : "‚úó"}`)
      }

      // ‚úÖ ETAPA 5: AVALIA√á√ÉO DE QUALIDADE INTEGRADA
      const qualityScore = this.calculateQualityScore(
        finalLyrics,
        syllableEnforcement,
        request.genre,
        terceiraViaAnalysis,
        melodicAnalysis,
      )

      console.log(`[MetaComposer-TURBO] üéØ Score final: ${qualityScore.toFixed(2)}`)

      if (qualityScore > bestScore) {
        bestScore = qualityScore
        bestResult = {
          lyrics: finalLyrics,
          title: this.extractTitle(finalLyrics, request),
          metadata: {
            iterations,
            finalScore: qualityScore,
            polishingApplied,
            preservedChorusesUsed: hasPreservedChoruses,
            rhymeScore: this.analyzeRhymes(finalLyrics, request.genre).score,
            rhymeTarget: this.getGenreRhymeTarget(request.genre).minScore,
            structureImproved: isRewrite,
            terceiraViaAnalysis: terceiraViaAnalysis,
            melodicAnalysis: melodicAnalysis,
            performanceMode: performanceMode,
          },
        }
      }

      const shouldStop =
        qualityScore >= this.MIN_QUALITY_SCORE &&
        terceiraViaAnalysis.score_geral >= 75 &&
        melodicAnalysis.flow_score >= 70 &&
        finalValidation.isValid // S√≥ para se valida√ß√£o final passou

      if (shouldStop) {
        console.log("[MetaComposer-TURBO] üéØ Crit√©rio de parada atingido!")
        break
      }
    }

    if (!bestResult) {
      throw new Error("Falha ao gerar composi√ß√£o")
    }

    console.log(`[MetaComposer-TURBO] üéµ Composi√ß√£o finalizada! Score: ${bestScore.toFixed(2)}`)
    return bestResult
  }

  /**
   * APLICA CORRE√á√ïES BASEADAS NA AN√ÅLISE TERCEIRA VIA
   */
  private static async applyTerceiraViaCorrections(
    lyrics: string,
    request: CompositionRequest,
    analysis: TerceiraViaAnalysis,
    genreConfig: any, // ‚úÖ RECEBE CONFIGURA√á√ÉO
  ): Promise<string> {
    const lines = lyrics.split("\n")
    const correctedLines: string[] = []
    let correctionsApplied = 0

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i]

      // ‚úÖ S√ì CORRIGE LINHAS QUE PRECISAM
      if (this.needsTerceiraViaCorrection(line, analysis)) {
        try {
          const context = this.buildLineContext(lines, i, request.theme)
          const correctedLine = await applyTerceiraViaToLine(
            line,
            i,
            context,
            request.performanceMode === "performance",
            request.additionalRequirements,
            request.genre,
          )

          if (correctedLine !== line) {
            correctionsApplied++
            console.log(`[TerceiraVia] üîÑ Linha ${i} corrigida: "${line}" ‚Üí "${correctedLine}"`)
          }

          correctedLines.push(correctedLine)
        } catch (error) {
          console.warn(`[TerceiraVia] ‚ùå Erro na linha ${i}, mantendo original`)
          correctedLines.push(line)
        }
      } else {
        correctedLines.push(line)
      }
    }

    console.log(`[MetaComposer-TURBO] ‚úÖ ${correctionsApplied} corre√ß√µes Terceira Via aplicadas`)
    return correctedLines.join("\n")
  }

  /**
   * POLIMENTO UNIVERSAL COM TERCEIRA VIA
   */
  private static async applyUniversalPolish(
    lyrics: string,
    genre: string,
    theme: string,
    syllableTarget: { min: number; max: number; ideal: number },
    performanceMode = "standard",
    genreConfig: any,
  ): Promise<string> {
    console.log(`[MetaComposer-TURBO] ‚ú® Polimento universal para: ${genre} (${performanceMode})`)

    let polishedLyrics = lyrics

    // ‚úÖ ETAPA 1: CORRE√á√ÉO DE RIMAS COM TERCEIRA VIA
    polishedLyrics = await this.applyRhymeEnhancement(polishedLyrics, genre, theme)

    // ‚úÖ ETAPA 2: CORRE√á√ÉO DE S√çLABAS INTELIGENTE
    const lines = polishedLyrics.split("\n")
    const finalLines: string[] = []

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i]

      if (line.startsWith("[") || line.startsWith("(") || line.includes("Instruments:") || !line.trim()) {
        finalLines.push(line)
        continue
      }

      const currentSyllables = countPoeticSyllables(line)
      const needsCorrection = currentSyllables < syllableTarget.min || currentSyllables > syllableTarget.max

      if (needsCorrection) {
        try {
          const polishedLine = await ThirdWayEngine.generateThirdWayLine(
            line,
            genre,
            genreConfig,
            `Polimento final para ${genre}`,
            performanceMode === "performance",
            `Ajuste para ${syllableTarget.ideal} s√≠labas po√©ticas`,
          )
          finalLines.push(polishedLine)
        } catch (error) {
          finalLines.push(line)
        }
      } else {
        finalLines.push(line)
      }
    }

    polishedLyrics = finalLines.join("\n")

    if (shouldUsePerformanceFormat(genre, performanceMode)) {
      console.log("[MetaComposer] üé≠ Aplicando formato de performance para sertanejo moderno...")
      polishedLyrics = formatSertanejoPerformance(polishedLyrics)
    } else if (performanceMode === "performance") {
      polishedLyrics = this.applyPerformanceFormatting(polishedLyrics, genre)
    }

    return polishedLyrics
  }

  /**
   * GERA REESCRITA DE LETRA EXISTENTE
   */
  private static async generateRewrite(request: CompositionRequest): Promise<string> {
    console.log("[MetaComposer] Gerando reescrita de letra existente...")

    if (!request.originalLyrics) {
      throw new Error("Original lyrics required for rewrite")
    }

    const syllableTarget = request.syllableTarget || this.getGenreSyllableConfig(request.genre)
    const genreConfig = getGenreConfig(request.genre)

    try {
      const rewritePrompt = `Voc√™ √© um compositor profissional de ${request.genre}. Reescreva esta letra mantendo a estrutura mas melhorando a qualidade.

LETRA ORIGINAL:
${request.originalLyrics}

TEMA: ${request.theme}
MOOD: ${request.mood}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
REGRAS ABSOLUTAS (N√ÉO PODEM SER QUEBRADAS - PRIORIDADE M√ÅXIMA)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

1. LIMITE DE 11 S√çLABAS PO√âTICAS (ABSOLUTO E INEGOCI√ÅVEL)
   - Cada verso DEVE ter no m√°ximo 11 s√≠labas po√©ticas
   - Ideal: ${syllableTarget.ideal} s√≠labas
   - M√≠nimo: ${syllableTarget.min} s√≠labas
   
   COMO CONTAR S√çLABAS PO√âTICAS:
   - Conte at√© a √∫ltima s√≠laba t√¥nica
   - Exemplo: "Eu vou seguir meu caminho sem olhar" = "Eu-vou-se-guir-meu-ca-mi-nho-sem-o-LHAR" = 11 s√≠labas ‚úì
   
   ESTRAT√âGIAS PARA ENCURTAR VERSOS:
   a) Use contra√ß√µes: voc√™‚Üíc√™, est√°‚Üít√°, para‚Üípra, estava‚Üítava
   b) Remova palavras desnecess√°rias: "muito", "bem", "t√£o", "j√°"
   c) Simplifique: "que estava tentando" ‚Üí "que tentava"
   d) Seja direto: "Eu vou seguir o meu caminho" ‚Üí "Vou seguir meu caminho"
   
   EXEMPLOS PR√ÅTICOS:
   ‚ùå "Eu me libertei de tudo que voc√™ fazia pra me prender" (16 s√≠labas)
   ‚úì "Me libertei do que c√™ fez pra me prender" (11 s√≠labas)
   
   ‚ùå "Hoje eu sou dona de mim e da minha pr√≥pria vida" (14 s√≠labas)
   ‚úì "Hoje sou dona de mim e da minha vida" (11 s√≠labas)

2. GRAM√ÅTICA PERFEITA (FRASES COMPLETAS E CORRETAS)
   - Cada verso = frase completa com sujeito + verbo + complemento
   - NUNCA versos incompletos ou quebrados
   
   ERROS COMUNS A EVITAR:
   ‚ùå "Vou n√£o podia aceitar" (dois verbos sem conectivo)
   ‚úì "Vou seguir sem aceitar"
   
   ‚ùå "Sa√≠ tentava me esconder" (dois verbos sem conectivo)
   ‚úì "Sa√≠ da sombra que tentava me esconder"
   
   ‚ùå "Cortei deixei pra tr√°s" (falta objeto)
   ‚úì "Cortei o la√ßo e deixei pra tr√°s"

3. NARRATIVA FLU√çDA (HIST√ìRIA COM COME√áO-MEIO-FIM)
   - Come√ßo: Apresenta a situa√ß√£o/problema
   - Meio: Desenvolve a transforma√ß√£o/conflito
   - Fim: Resolu√ß√£o com empoderamento
   - Cada verso deve CONECTAR com o anterior
   - SEM mudan√ßas abruptas de assunto

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
REGRAS DESEJ√ÅVEIS (IMPORTANTE MAS FLEX√çVEL)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

4. VOCABUL√ÅRIO SERTANEJO MODERNO
   PREFIRA: biqu√≠ni, PIX, story, boteco, pickup, praia, zap, rol√™, copo de vit√≥ria
   EVITE: cora√ß√£o em peda√ßos, l√°grimas, solid√£o, mundo desabou, dor vazio

5. LINGUAGEM COLOQUIAL BRASILEIRA
   - Use: t√¥, c√™, pra, n√©, mano, v√©io
   - Fale como brasileiro no dia-a-dia
   - Simples e direto, como numa conversa

6. ESTRUTURA
   - Use PART A (verso), PART B (refr√£o), PART C (ponte)
   - Refr√£o deve ser chiclete e repetitivo
   - Mantenha a mesma quantidade de se√ß√µes da original

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PROCESSO DE CRIA√á√ÉO (SIGA ESTA ORDEM)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

PASSO 1: PENSE ANTES DE ESCREVER
- Qual √© a hist√≥ria que quero contar?
- Como posso contar em versos curtos (11 s√≠labas)?
- Quais palavras posso encurtar ou remover?

PASSO 2: ESCREVA CADA VERSO
- Escreva o verso
- CONTE as s√≠labas po√©ticas
- Se passar de 11, REESCREVA usando as estrat√©gias acima
- Verifique se a gram√°tica est√° correta

PASSO 3: REVISE ANTES DE FINALIZAR
‚úì Todos os versos t√™m 11 s√≠labas ou menos?
‚úì Todas as frases est√£o completas e corretas?
‚úì A hist√≥ria flui do come√ßo ao fim?
‚úì Usei vocabul√°rio moderno e coloquial?
‚úì Evitei clich√™s dram√°ticos?

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SEU OBJETIVO FINAL (LEIA COM ATEN√á√ÉO)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Voc√™ DEVE entregar uma letra que tenha SIMULTANEAMENTE:
‚úì GRAM√ÅTICA PERFEITA (frases completas e corretas)
‚úì NARRATIVA FLU√çDA (hist√≥ria com come√ßo-meio-fim)
‚úì M√ÅXIMO 11 S√çLABAS POR VERSO (ABSOLUTO, N√ÉO NEGOCI√ÅVEL)

N√ÉO ABRIMOS M√ÉO DE NENHUM DESSES DETALHES.

IMPORTANTE:
- Se um verso ficar com mais de 11 s√≠labas, voc√™ DEVE simplific√°-lo
- √â MELHOR uma frase simples com 11 s√≠labas do que uma frase complexa com 13
- Qualidade da narrativa N√ÉO justifica exceder 11 s√≠labas
- Se n√£o conseguir expressar a ideia em 11 s√≠labas, MUDE a ideia para algo mais simples

EXEMPLO DO QUE FAZER:
‚ùå "Pago tudo do meu jeito, sem ningu√©m pra dar conselho" (15 s√≠labas - INACEIT√ÅVEL)
‚úì "Pago tudo do meu jeito, sem conselho" (11 s√≠labas - PERFEITO)

‚ùå "Achava lindo o decote da vizinha do lado" (14 s√≠labas - INACEIT√ÅVEL)
‚úì "Achava lindo o decote da vizinha" (11 s√≠labas - PERFEITO)

N√ÉO ENVIE a letra at√© que TODOS os versos tenham 11 s√≠labas ou menos.
Revise CADA verso antes de finalizar.

Retorne APENAS a letra reescrita:`

      const response = await generateText({
        model: "openai/gpt-4o",
        prompt: rewritePrompt,
        temperature: 0.7,
      })

      return response.text || request.originalLyrics
    } catch (error) {
      console.error("[MetaComposer] Erro ao gerar reescrita:", error)
      return request.originalLyrics
    }
  }

  /**
   * GERA LETRA COM REFR√ïES PRESERVADOS
   */
  private static async generateWithPreservedChoruses(
    preservedChoruses: string[],
    request: CompositionRequest,
    syllableEnforcement: { min: number; max: number; ideal: number },
  ): Promise<string> {
    console.log("[MetaComposer] Gerando letra com refr√µes preservados...")

    const syllableTarget = request.syllableTarget || this.getGenreSyllableConfig(request.genre)
    const genreConfig = getGenreConfig(request.genre)

    try {
      const chorusPrompt = `Voc√™ √© um compositor profissional de ${request.genre}. Crie uma letra usando EXATAMENTE estes refr√µes:

${preservedChoruses.join("\n\n")}

TEMA: ${request.theme}
MOOD: ${request.mood}

REGRAS ABSOLUTAS:

1. S√çLABAS: M√°ximo 11 por verso (conte antes de finalizar)
2. GRAM√ÅTICA: Frases completas em portugu√™s correto
3. VOCABUL√ÅRIO: Use biqu√≠ni, PIX, story, boteco (evite clich√™s dram√°ticos)
4. LINGUAGEM: Coloquial brasileira (t√¥, c√™, pra)
5. NARRATIVA: Hist√≥ria flu√≠da com come√ßo-meio-fim

Retorne a letra completa com os refr√µes preservados:`

      const response = await generateText({
        model: "openai/gpt-4o",
        prompt: chorusPrompt,
        temperature: 0.7,
      })

      return response.text || ""
    } catch (error) {
      console.error("[MetaComposer] Erro ao gerar letra com refr√µes preservados:", error)
      return ""
    }
  }

  /**
   * GERA LETRA DIRETAMENTE SEM RESTRI√á√ïES DE REFR√ÉO
   */
  private static async generateDirectLyrics(
    request: CompositionRequest,
    syllableEnforcement: { min: number; max: number; ideal: number },
  ): Promise<string> {
    console.log("[MetaComposer] Gerando letra diretamente...")

    const genreConfig = getGenreConfig(request.genre)

    try {
      const directPrompt = `Voc√™ √© um compositor profissional de ${request.genre}. Crie uma letra original sobre: ${request.theme}

MOOD: ${request.mood}
${request.rhythm ? `RITMO: ${request.rhythm}` : ""}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
REGRAS ABSOLUTAS (N√ÉO PODEM SER QUEBRADAS)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

1. LIMITE DE 11 S√çLABAS PO√âTICAS (ABSOLUTO)
   - M√°ximo: 11 s√≠labas por verso
   - Ideal: ${syllableEnforcement.ideal} s√≠labas
   
   ESTRAT√âGIAS PARA MANTER 11 S√çLABAS:
   a) Contra√ß√µes: voc√™‚Üíc√™, est√°‚Üít√°, para‚Üípra
   b) Seja direto: "Eu vou seguir" ‚Üí "Vou seguir"
   c) Remova palavras extras: "muito", "bem", "t√£o"
   
   EXEMPLOS:
   ‚ùå "Eu me libertei de tudo aquilo que me prendia" (14 s√≠labas)
   ‚úì "Me libertei do que me prendia" (10 s√≠labas)

2. GRAM√ÅTICA PERFEITA
   - Cada verso = frase completa (sujeito + verbo + complemento)
   - NUNCA: "Vou n√£o podia" ‚ùå
   - SEMPRE: "Vou seguir sem voc√™" ‚úì

3. NARRATIVA FLU√çDA
   - Come√ßo: Apresenta situa√ß√£o
   - Meio: Desenvolve transforma√ß√£o
   - Fim: Resolu√ß√£o com empoderamento

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PROCESSO (SIGA ESTA ORDEM)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

PASSO 1: PLANEJE A HIST√ìRIA
- Qual √© a situa√ß√£o inicial?
- O que acontece no meio?
- Como termina?

PASSO 2: ESCREVA VERSO POR VERSO
- Escreva o verso
- CONTE as s√≠labas
- Se > 11, REESCREVA usando contra√ß√µes e simplifica√ß√µes
- Verifique gram√°tica

PASSO 3: REVISE TUDO
‚úì Todos os versos ‚â§ 11 s√≠labas?
‚úì Gram√°tica perfeita?
‚úì Hist√≥ria flu√≠da?

ESTRUTURA:
[PART A - Verse 1]
4 linhas (11 s√≠labas cada)

[PART B - Chorus]
4 linhas chiclete (11 s√≠labas cada)

[PART A2 - Verse 2]
4 linhas (11 s√≠labas cada)

[PART B - Chorus]
Repete

[PART C - Bridge]
2 linhas de cl√≠max (11 s√≠labas cada)

[PART B - Final Chorus]
Refr√£o final

N√ÉO ENVIE at√© que TODOS os versos tenham ‚â§ 11 s√≠labas.

Retorne APENAS a letra:`

      const response = await generateText({
        model: "openai/gpt-4o",
        prompt: directPrompt,
        temperature: 0.7,
      })

      return response.text || ""
    } catch (error) {
      console.error("[MetaComposer] Erro ao gerar letra direta:", error)
      throw error
    }
  }

  /**
   * CALCULA SCORE DE QUALIDADE INTEGRADO
   */
  private static calculateQualityScore(
    lyrics: string,
    syllableTarget: { min: number; max: number; ideal: number },
    genre: string,
    terceiraViaAnalysis: TerceiraViaAnalysis | null,
    melodicAnalysis: any,
  ): number {
    let score = 0
    let weights = 0

    // Terceira Via score (40% do peso)
    if (terceiraViaAnalysis) {
      score += (terceiraViaAnalysis.score_geral / 100) * 0.4
      weights += 0.4
    }

    // Melodic flow score (30% do peso)
    if (melodicAnalysis) {
      score += (melodicAnalysis.flow_score / 100) * 0.3
      weights += 0.3
    }

    // Syllable compliance (20% do peso)
    const lines = lyrics.split("\n").filter((l) => l.trim() && !l.startsWith("[") && !l.startsWith("("))
    let syllableCompliance = 0
    lines.forEach((line) => {
      const count = countPoeticSyllables(line)
      if (count >= syllableTarget.min && count <= syllableTarget.max) {
        syllableCompliance++
      }
    })
    if (lines.length > 0) {
      score += (syllableCompliance / lines.length) * 0.2
      weights += 0.2
    }

    // Rhyme quality (10% do peso)
    const rhymeAnalysis = this.analyzeRhymes(lyrics, genre)
    score += (rhymeAnalysis.score / 100) * 0.1
    weights += 0.1

    return weights > 0 ? score / weights : 0
  }

  /**
   * EXTRAI T√çTULO DA LETRA
   */
  private static extractTitle(lyrics: string, request: CompositionRequest): string {
    const lines = lyrics.split("\n")

    // Procura por linha de t√≠tulo expl√≠cita
    for (const line of lines) {
      if (line.toLowerCase().includes("t√≠tulo:") || line.toLowerCase().includes("title:")) {
        return line.split(":")[1]?.trim() || "Sem T√≠tulo"
      }
    }

    // Usa primeira linha significativa como t√≠tulo
    for (const line of lines) {
      const cleaned = line.trim()
      if (cleaned && !cleaned.startsWith("[") && !cleaned.startsWith("(") && cleaned.length > 3) {
        return cleaned.substring(0, 50)
      }
    }

    return `${request.theme} - ${request.genre}`
  }

  /**
   * ANALISA QUALIDADE DAS RIMAS
   */
  private static analyzeRhymes(
    lyrics: string,
    genre: string,
  ): { score: number; richRhymes: number; totalRhymes: number } {
    const lines = lyrics.split("\n").filter((l) => l.trim() && !l.startsWith("[") && !l.startsWith("("))

    let richRhymes = 0
    let totalRhymes = 0

    // An√°lise simplificada de rimas
    for (let i = 0; i < lines.length - 1; i++) {
      const line1 = lines[i].trim()
      const line2 = lines[i + 1].trim()

      if (line1 && line2) {
        const lastWord1 = line1.split(" ").pop()?.toLowerCase() || ""
        const lastWord2 = line2.split(" ").pop()?.toLowerCase() || ""

        if (lastWord1.length > 2 && lastWord2.length > 2) {
          const suffix1 = lastWord1.slice(-3)
          const suffix2 = lastWord2.slice(-3)

          if (suffix1 === suffix2) {
            totalRhymes++
            // Rima rica: mais de 3 caracteres iguais
            if (lastWord1.slice(-4) === lastWord2.slice(-4)) {
              richRhymes++
            }
          }
        }
      }
    }

    const score = totalRhymes > 0 ? (richRhymes / totalRhymes) * 100 : 0
    return { score, richRhymes, totalRhymes }
  }

  /**
   * OBT√âM TARGET DE RIMAS PARA O G√äNERO
   */
  private static getGenreRhymeTarget(genre: string): { minScore: number; richRhymePercentage: number } {
    // Targets padr√£o baseados no g√™nero
    const targets: Record<string, { minScore: number; richRhymePercentage: number }> = {
      "sertanejo-moderno": { minScore: 70, richRhymePercentage: 60 },
      "sertanejo-universitario": { minScore: 70, richRhymePercentage: 60 },
      piseiro: { minScore: 65, richRhymePercentage: 55 },
      forro: { minScore: 65, richRhymePercentage: 55 },
      funk: { minScore: 60, richRhymePercentage: 50 },
      trap: { minScore: 60, richRhymePercentage: 50 },
      default: { minScore: 65, richRhymePercentage: 55 },
    }

    return targets[genre] || targets["default"]
  }

  /**
   * VERIFICA SE LINHA PRECISA DE CORRE√á√ÉO TERCEIRA VIA
   */
  private static needsTerceiraViaCorrection(line: string, analysis: TerceiraViaAnalysis): boolean {
    // N√£o corrige tags, instru√ß√µes ou linhas vazias
    if (!line.trim() || line.startsWith("[") || line.startsWith("(") || line.includes("Instruments:")) {
      return false
    }

    // Corrige se score geral est√° baixo
    if (analysis.score_geral < 70) {
      return true
    }

    // Corrige se h√° pontos fracos identificados
    if (analysis.pontos_fracos && analysis.pontos_fracos.length > 0) {
      return true
    }

    return false
  }

  /**
   * CONSTR√ìI CONTEXTO PARA CORRE√á√ÉO DE LINHA
   */
  private static buildLineContext(lines: string[], lineIndex: number, theme: string): string {
    const contextLines: string[] = []

    // Adiciona linha anterior se existir
    if (lineIndex > 0) {
      contextLines.push(`Linha anterior: ${lines[lineIndex - 1]}`)
    }

    // Adiciona linha atual
    contextLines.push(`Linha atual: ${lines[lineIndex]}`)

    // Adiciona pr√≥xima linha se existir
    if (lineIndex < lines.length - 1) {
      contextLines.push(`Pr√≥xima linha: ${lines[lineIndex + 1]}`)
    }

    contextLines.push(`Tema: ${theme}`)

    return contextLines.join("\n")
  }

  /**
   * APLICA MELHORIAS DE RIMA
   */
  private static async applyRhymeEnhancement(lyrics: string, genre: string, theme: string): Promise<string> {
    console.log("[MetaComposer] Aplicando melhorias de rima...")

    // Implementa√ß√£o simplificada - retorna lyrics original
    // Em produ√ß√£o, isso usaria o rhyme-enhancer
    return lyrics
  }

  /**
   * APLICA FORMATA√á√ÉO PERFORM√ÅTICA
   */
  private static applyPerformanceFormatting(lyrics: string, genre: string): string {
    console.log("[MetaComposer] Aplicando formata√ß√£o perform√°tica...")

    // Garante que tags est√£o em ingl√™s e versos em portugu√™s
    let formatted = lyrics

    // Converte tags comuns para ingl√™s
    formatted = formatted.replace(/\[Intro\]/gi, "[Intro]")
    formatted = formatted.replace(/\[Verso\s*(\d*)\]/gi, "[Verse$1]")
    formatted = formatted.replace(/\[Refr√£o\]/gi, "[Chorus]")
    formatted = formatted.replace(/\[Ponte\]/gi, "[Bridge]")
    formatted = formatted.replace(/\[Final\]/gi, "[Outro]")

    return formatted
  }

  private static detectCriticalViolations(
    lyrics: string,
  ): Array<{ line: string; syllables: number; lineNumber: number }> {
    const lines = lyrics.split("\n")
    const violations: Array<{ line: string; syllables: number; lineNumber: number }> = []

    lines.forEach((line, index) => {
      const trimmed = line.trim()

      // Ignora tags, instru√ß√µes e linhas vazias
      if (!trimmed || trimmed.startsWith("[") || trimmed.startsWith("(") || trimmed.includes("Instruments:")) {
        return
      }

      const syllables = countPoeticSyllables(trimmed)
      if (syllables > this.ABSOLUTE_MAX_SYLLABLES) {
        violations.push({
          line: trimmed,
          syllables,
          lineNumber: index + 1,
        })
      }
    })

    return violations
  }

  private static applyEmergencyCorrection(lyrics: string, maxSyllables: number): string {
    console.log(`[MetaComposer] ‚ö†Ô∏è Corre√ß√£o de emerg√™ncia DESABILITADA`)
    console.log(`[MetaComposer] ‚ÑπÔ∏è Retornando lyrics original - IA deve regenerar`)

    // N√ÉO remove palavras - isso quebra a gram√°tica
    // A IA deve regenerar a letra inteira se necess√°rio
    return lyrics
  }

  /**
   * VALIDA√á√ÉO FINAL RIGOROSA - SIMPLIFICADA E EFICIENTE
   * Garante que TODAS as valida√ß√µes existentes sejam executadas e BLOQUEIEM sa√≠da se falharem
   */
  private static validateFinalLyrics(
    lyrics: string,
    genre: string,
    syllableTarget: { min: number; max: number; ideal: number },
  ): {
    isValid: boolean
    criticalErrors: string[]
    warnings: string[]
    syllableCompliance: number
    rhymeQuality: number
    verseIntegrity: number
    hasNarrative: boolean
  } {
    const criticalErrors: string[] = []
    const warnings: string[] = []

    // 1. S√çLABAS - NUNCA MAIS DE 11
    const lines = lyrics.split("\n").filter((l) => {
      const t = l.trim()
      return t && !t.startsWith("[") && !t.startsWith("(") && !t.includes("Instruments:")
    })

    let syllableCompliant = 0
    lines.forEach((line, i) => {
      const count = countPoeticSyllables(line)
      if (count > this.ABSOLUTE_MAX_SYLLABLES) {
        criticalErrors.push(`Linha ${i + 1} tem ${count} s√≠labas (m√°ximo: 11)`)
      } else if (count >= syllableTarget.min && count <= syllableTarget.max) {
        syllableCompliant++
      }
    })
    const syllableCompliance = lines.length > 0 ? (syllableCompliant / lines.length) * 100 : 0

    // 2. INTEGRIDADE DE VERSOS - sem versos quebrados
    const integrityResult = validateVerseIntegrity(lyrics)
    if (integrityResult.brokenVerses > 0) {
      integrityResult.issues.forEach((issue) => {
        if (issue.severity === "error") {
          criticalErrors.push(`Verso quebrado linha ${issue.line}: ${issue.issues[0]}`)
        }
      })
    }
    const verseIntegrity = lines.length > 0 ? ((lines.length - integrityResult.brokenVerses) / lines.length) * 100 : 0

    // 3. NARRATIVA - hist√≥ria flu√≠da
    const narrativeValidation = validateNarrativeFlow(lyrics, genre)
    if (narrativeValidation.abruptChanges.length > 1) {
      criticalErrors.push(`${narrativeValidation.abruptChanges.length} mudan√ßas abruptas na narrativa`)
    }
    const hasNarrative = narrativeValidation.score >= 70

    // 4. RIMAS - qualidade m√≠nima
    const rhymeValidation = validateRhymesForGenre(lyrics, genre)
    const rhymeQuality = rhymeValidation.analysis.score

    const isValid =
      criticalErrors.length === 0 && // Sem erros cr√≠ticos
      syllableCompliance >= 80 && // 80% das linhas com s√≠labas corretas
      verseIntegrity >= 80 && // 80% dos versos √≠ntegros
      hasNarrative // Narrativa flu√≠da

    return {
      isValid,
      criticalErrors,
      warnings,
      syllableCompliance,
      rhymeQuality,
      verseIntegrity,
      hasNarrative,
    }
  }

  /**
   * CORRE√á√ïES EMERGENCIAIS FINAIS
   * Aplica corre√ß√µes dr√°sticas se necess√°rio para garantir que a letra seja v√°lida
   */
  private static applyFinalEmergencyFixes(
    lyrics: string,
    syllableTarget: { min: number; max: number; ideal: number },
    genre: string,
  ): string {
    console.log("[MetaComposer] ‚ö†Ô∏è Corre√ß√µes emergenciais finais DESABILITADAS")
    console.log("[MetaComposer] ‚ÑπÔ∏è Retornando lyrics original - sistema deve regenerar")

    // N√ÉO aplica corre√ß√µes que quebram frases
    // Se chegou aqui com erros, o sistema deve REGENERAR a letra inteira
    return lyrics
  }
}
